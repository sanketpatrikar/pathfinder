---
type: exhaustive
order: 3
solverKey: branchAndBoundOnCost
friendlyName: Branch and Bound (Cost)
defaults:
  evaluatingDetailLevel: 2
  maxEvaluatingDetailLevel: 2
---

# Branch and Bound on Cost

This is a recursive algorithm, similar to depth first search, that is guaranteed to find the optimal solution.

The candidate solution space is generated by systematically traversing possible paths, and discarding large subsets of fruitless candidates by comparing the current solution to an upper and lower bound. In this case, the upper bound is the best path found so far.

While evaluating paths, if at any point the current solution is already more expensive (longer) than the best complete path discovered, there is no point continuing.

For example, imagine:

1. A -> B -> C -> D -> E -> A was already found with a cost of 100.
2. We are evaluating A -> C -> E, which has a cost of 110. There is **no point** evaluating the remaining solutions.
3. Instead of continuing to evaluate all of the child solutions from here, we can go down a different path, eliminating candidates not worth evaluating:
   - `A -> C -> E -> D -> B -> A`
   - `A -> C -> E -> B -> D -> A`

Implementation is very similar to depth first search, with the exception that we cut paths that are already longer than the current best.

## Implementation

```javascript
const branchAndBoundOnCost = async (
  points,
  path = [],
  visited = null,
  overallBest = Infinity
) => {
  if (visited === null) {
    // initial call
    path = [points.shift()];
    points = new Set(points);
    visited = new Set();
  }

  // figure out which points are left
  const available = setDifference(points, visited);

  // calculate the cost, from here, to go home
  const backToStart = [...path, path[0]];
  const cost = pathCost(backToStart);

  if (cost > overallBest) {
    // we may not be done, but have already traveled further than the best path
    // no reason to continue
    return [null, null];
  }

  // still cheaper than the best, keep going deeper, and deeper, and deeper...

  if (available.size === 0) {
    // at the end of the path, return where we're at
    return [cost, backToStart];
  }

  let [bestCost, bestPath] = [null, null];

  // for every point yet to be visited along this path
  for (const p of available) {
    // go to that point
    visited.add(p);
    path.push(p);

    // RECURSE - go through all the possible points from that point
    const [curCost, curPath] = await branchAndBoundOnCost(
      points,
      path,
      visited,
      overallBest
    );

    // if that path is better and complete, keep it
    if (curCost && (!bestCost || curCost < bestCost)) {
      [bestCost, bestPath] = [curCost, curPath];

      if (!overallBest || bestCost < overallBest) {
        // found a new best complete path
        overallBest = bestCost;
        self.setBestPath(bestPath, bestCost);
      }
    }

    // go back up and make that point available again
    visited.delete(p);
    path.pop();
  }

  return [bestCost, bestPath];
};
```
